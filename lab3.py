def hamming_distance(p, q):  # BA1G
    mismatch = 0
    for i in range(0, len(p)):
        if p[i] != q[i]:
            mismatch += 1

    return mismatch


def approximation_find(pattern, text, d):  # BA1H
    indices = []
    for i in range(0, len(text) - len(pattern) + 1):
        if hamming_distance(text[i:i + len(pattern)], pattern) <= d:
            indices.append(i)

    return indices

def generate_kmers(k, bases):
    if k == 1:
        return bases

    small_kmers = generate_kmers(k - 1, bases)
    k_mers = []
    for kmer in small_kmers:
        for b in bases:
            k_mers.append(kmer + b)

    return k_mers

def neighbors(pattern, d):  # BA1N
    if d == 0:
        return {pattern}
    if len(pattern) == 1:
        return {'A', 'G', 'C', 'T'}

    neighborhood = set()
    suffix_neighbors = neighbors(pattern[1:], d)
    for text in suffix_neighbors:
        if hamming_distance(pattern[1:], text) < d:
            for c in "AGTC":
                new = c + text
                neighborhood.add(new)

        else:
            new = pattern[0] + text
            neighborhood.add(new)

    return neighborhood


def motif_enumeration(dna, k, d):  # BA2A
    s = ""
    patterns = set()
    n_bs = set()  # all neighbors
    first_string = dna[0]
    for j in range(len(dna)):
        for i in range(0, len(first_string) - k + 1):
            kmers = neighbors(dna[j][i:i + k], d)
            n_bs |= kmers  # union of sets

    for kmer in n_bs:
        matches = True
        for i in range(0, len(dna)):
            if len(approximation_find(kmer, dna[i], d)) == 0:
               matches = False

        if matches:
            patterns.add(kmer)

    indices = list(patterns)
    for i in range(len(indices)):
        s += str(indices[i])
        if i != len(indices) - 1:
            s += " "
    return s



print(motif_enumeration(['GACATACGTCATGGGCATCATCTGA',
'TCATAAGTGCCATCCAGACGGTGTG',
'CATCGTTGAGGAGGTTACCGTTATT',
'CATCAAGGTTTTACCAGTGATCTCC',
'CTGTCTGTAGTTCCTCATCGTTGTC',
'TGCAGGGTTTCTCCTCGGTCCATCA',
'ATTTGTGTAATTGAGCATCTTTGTA',
'GCCAGTAGGAGGGTATACAGCATCG',
'TGAATACCTAGGTACGCGATCATCT',
'GAAAGCATCAGACGCTTAATGACAC'], 5, 1))


def distance_between_pattern_and_string(pattern, dna):  # BA2H
    k = len(pattern)
    distance = 0
    for gene in dna:
        ham_dis = float('inf')
        for i in range(0, len(gene)-k+1):
            if ham_dis > hamming_distance(pattern, gene[i:i+k]):
                ham_dis = hamming_distance(pattern, gene[i:i+k])

        distance = distance + ham_dis

    return distance

# strings = "TTACCCTAGAAGTCTGTCTAGGCGACCCACGGGGGTGAACCCGTTCTAACTTCCTTGGCACGAAATGATCAACCCCGTACTTCCCGACGT AAGTCACCCTTACCCCTATCCCTTTTATTGAATGCGGTGACGATCCTTAAATTCCGCGCCTGTGATGCTGCTGCCGAATACAAACGCTAG CCGGCAGGTTGACCGACAATATCCCCGAGACCAAGTGGAATGCTCGGTGTCTACACCGATTAGCTATTCTGTAATACTCTAGGAGGCTTT GTTACGTTGAATAGGCAATTAAGAGATTAACACTACGACAAGACGGTTATCTTTGGATGAGGCGACTTCTCCCCAATTCGAGTTTGGTCA TGCCTATAGCGCGGCGATAAAGTTCATTGCGTTCCCTAACAGCTTCCAGGGGCCGACGGGCGCGGTGGCTGAACATCCCAATGTTCGGAC ATGTAGTTTTGAGTTTATAGCGTCTGGGCAACTCAGCAAGGTTTCGACTCGTCACTTATTGAGATCGGCGGCTACTGGTTGGACCGGTCA TTTTTGGCGTTGATATTTTCATTCAGCGCGGTCTAAGGAAATGCCTTTGGGCCCGGGACCGTACGTGCCCAATGCCGACATAACACCTGG TACATCAGCGCTGCGATTACTTTCCTGATGCGCAGAGTCTTCATGCTCTTTCACCAGGGGATGATGGGAGGTAGGCAACCCTTTGCCCGA CGTTGCGGTAAGCCTGGTACCGCAAACAGATTCAGTACTCTGATCCTCAGCCACCTCCGCCATAGTAATTGAGAATACAATCCTAACCCA GCCTGCTCTGTGTCGGTTCTCCAGACGGATCGATGTTTTGCGTCCTGGTGAATACTTGGTCAGGCGGGTTCCGAAACCCGGTGGAAGATA GACAGGGAGTACATTTGATTAGTTGCTGGAAGCTACCGTAAATCAAAATCCGTCTATTCTTCCTTTACTCACTCGTGGAAATAATTCCGC CTTTCGGGAGTTACCGAATCGAGAGAGTGTGGATAAGGAACAGCGATTAACGGGCAGCAGTAGATACATATCCCAATGAGCTATCGCCTG AAACTAAACCAGCGTATCGTAATGTAATTGAGTTATCCAAAGTAACTCGCCCCCTGGAGTAACTAAGCACATCTACCTATTGAAGGCACA ACGAGTTGCGGCGGCGATGACATGGTGAGATCACCTCGTCTCAATCGGCACGCTGGAGATGCTCGGCAATACTGATTGGGGATTTTCTGC AAGTCAGCTTGACTTGTGTGGTTGGGCTCCAATTGAGGGCAACGGATGTACTGGAATTCGTCCCGATATATTTGTTGTAAATTCAGAATA TTGTGATTTGCCTCGATCCGGTCATTGCAGAGTGTATTTCAGCGCAAGTCGGGGTGCTCGTGGACGATGTCGGGGGTGCTGGACTATCCT GATGTGAGTCTCGTTCTAACGATACGTTAGAGATAAAGCCCCTCTTTGAGTCTAGCGTCCAGCGTCTCAACAATGAGTCGAAGCATTGGT AAGTTGAGGGAAAGCTTGTATTAACGCAAGCCACTGAGGCGGGGTTCGTTACAGGTAGTTTTTATGGCTTACATGAGATTTGGCGAGACT TCGGAGCGTCCCCATGTCCGGCTTCGGTAGGGGCTGGTTGGACTCCGTATCAGTTGACCTAGTGGAAGTTTGTTATTATCCATGTTGGAC CGCTAGCTCCGAGCCGCGGATCAGTTGTTTATTATAGTGTGACAGCGGAGTGATTACGCTTCAAGCACATATGCTACCGCCCCCAGATTT GAACTCTTAGAGTATGATGATGCTGCTAAGCTGCAGCGATTGGGTTGATCAACTTAACCGGGGTCAGTTGAGTGCAAACTGGACGATAAA GAAAGCTGCTGGCTAACAGGGCAGAGCGTAAAGGTCTTCAGTATTAAACAACCCTGTTCAAACGGGAAACCGGGAGCTTTGCGATGCGGT GATACTCATTCCGACGTATTCACACGTTACCGCTTCGCGACTCGATGCCCTAAAACAGTACCTTTTGGCCGGATCTTCTGTTAAATGCGG CCAGAATACCTAATGGGGGAAGGGTGCCCCTCGCTTAATCCGTTAGTATTGTCACCACCCGCTAAGATTCGTGTCATTCATGTGGATATG GAGCCGCTATTTTATTACGTGCGGGAGGCCGCCCAGCGGGTTGCTTAACGATAGCGGCGCTGCGTTGGAAGGACCGTAGGGATGTGTGCA AAATTGGTGTAGCCTCTGTCGCTTCATTTAACACGCAAAAGCGTACGTTTGGGAAGATCCCAACATTCAACCGGGCCTCGAACAATGATG GTAAGGCCCTCCTCGATAGGCACCAGGTTGAGCCAAACGTCTGCTTACATGTGGTTTCCATTGATTCTTGTTTAACGCAAGCGTTCCGCA GAGTACGATTCGGCACTGATTTGACCAACGCAGTGACCCGTGTACGTGATCGTCCCCAGGGAGGTTGCCCTGTCACCTGTTATGGCCAGA GGAGACTCGGCTCAGCTCGATTACCAGTATGTTGTCTGCTTGTAAAGTGCGAACCATGTACGAACCATCCCAGATCCGGAAGGTCTAGGT TAGTCCGCACGTTCTCGGGTGCCCTCAAGGGGTTGTGAGAAACCCATCGGGGGACCTCGGAATACCGCCGACGATGAAATGGTCGAAGAG CGCTGCAGCGTTCCCCGCAGTGTGCCGCTGCTCTACTCGCTATCCACGACTCAATAATCTATGGGTCAAGCTCTTTCCAAATAGATCTGT GCTAGGGGCGGTTGTCACCGACTCCCCCATTTCACTCGAGATTGATCGTTGCGCCGTACAGCTTTTCACGGTGTCAGTCCTTCATAGTTT".split(" ")
# print(distance_between_pattern_and_string("GGCGGAC", strings))


def median_string(dna, k):  # BA2B
    median = ""
    distance = float('inf')
    all_kmers = generate_kmers(k, ['A', 'T', 'G', 'C'])
    for kmer in all_kmers:
        if distance > distance_between_pattern_and_string(kmer, dna):
            distance = distance_between_pattern_and_string(kmer, dna)
            median = kmer

    return median

strings= ['AACGGATTTGTACTCGACCAGTCTGTCGAGAATAAAAAGAAG',
'GCTGTAGGCGTTTTCTAGAAGATGTGCACGCATGTTTACTTT',
'GCGACATAGAGCAAGAGGACGGTGTTTAGGGCCCTAAATTTC',
'CCAGCTGATACCTCCTTTAAGAGGTCTCGCACTCGTAGTGTC',
'AGTAATAAGATGACCTGCACAATCATCTACAATTTACCCCTC',
'CGTATACACCCTTATCCATCTACGCAATTGCCGTGCAAGAGG',
'ACGGCATGGGCCAAGAAGACGAGCACACAGGTTCACGCGACG',
'CCCAAAATCCCTTCACAGAAGAAGCTTACCGTCATCCGGAAC',
'AGGGTCTGGTTCCCCGTCTACTCTAAGAAGGACCATGATGAA',
'CAATAGGCGCCAAAGATGACATCGATGCAGGACTGATGGGGA']

print(median_string(strings, 6))


def profile_most_probable_kmer(text, k, profile_matrix):  # BA2C
    mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
    k_mer_probability = {}

    for i in range(len(text) - k + 1):
        k_mer = text[i:i+k]
        p = 1

        for j in range(len(k_mer)):
            p *= profile_matrix[mapping[k_mer[j]]][j]

        k_mer_probability[k_mer] = p

    maximum = max(k_mer_probability.values())
    for key in k_mer_probability:
        if k_mer_probability[key] == maximum:
            return key


matrix = [
    [0.357, 0.286, 0.25, 0.25, 0.107, 0.321, 0.25],
    [0.107, 0.286, 0.286, 0.25, 0.286, 0.25, 0.25],
    [0.179, 0.25, 0.286, 0.321, 0.357, 0.214, 0.286],
    [0.357, 0.179, 0.179, 0.179, 0.25, 0.214, 0.214]
]

print(profile_most_probable_kmer("TTCAGCGCCGATTATGTGTCTTTACTGACCACTTCAATTGTCAACGTTGCAATTTGGGCTGTACATCCTCGAGCGGCTTTCCGTTTAGCACGTGTTATGATGTTTCTTCCAAGAAGTGCTTTGGTCCTTGGGAGACGACACGATGGCGTCGGCGACCACCAAACCTTTAAAACTCCGTCGACCGAACCTCTAGTGCTGCA",7,matrix))